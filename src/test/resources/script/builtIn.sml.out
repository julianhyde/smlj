(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)

(* Structures -------------------------------------------------- *)
General;
val it = {ignore=fn,op o=fn}
  : {ignore:'a -> unit, op o:('b -> 'c) * ('d -> 'b) -> 'd -> 'c}

List;
val it =
  {all=fn,app=fn,at=fn,collate=fn,concat=fn,drop=fn,exists=fn,filter=fn,
   find=fn,foldl=fn,foldr=fn,getItem=fn,hd=fn,last=fn,length=fn,map=fn,
   mapPartial=fn,nil=[],nth=fn,null=fn,op @=fn,partition=fn,rev=fn,
   revAppend=fn,tabulate=fn,take=fn,tl=fn}
  : {all:('a -> bool) -> 'a list -> bool, app:('b -> unit) -> 'b list -> unit, at:'c list * 'c list -> 'c list, collate:('d * 'd -> order) -> 'd list * 'd list -> order, concat:'e list list -> 'e list, drop:'f list * int -> 'f list, exists:('g -> bool) -> 'g list -> bool, filter:('h -> bool) -> 'h list -> 'h list, find:('i -> bool) -> 'i list -> 'i option, foldl:('j * 'k -> 'k) -> 'k -> 'j list -> 'k, foldr:('l * 'm -> 'm) -> 'm -> 'l list -> 'm, getItem:'n list -> ('n * 'n list) option, hd:'o list -> 'o, last:'p list -> 'p, length:'q list -> int, map:('r -> 's) -> 'r list -> 's list, mapPartial:('t -> 'u option) -> 't list -> 'u list, nil:'v list, nth:'w list * int -> 'w, null:'x list -> bool, op @:'y list * 'y list -> 'y list, partition:('z -> bool) -> 'z list -> 'z list * 'z list, rev:'ba list -> 'ba list, revAppend:'bb list * 'bb list -> 'bb list, tabulate:int * (int -> 'bc) -> 'bc list, take:'bd list * int -> 'bd list, tl:'be list -> 'be list}

List.rev;
val it = fn : 'a list -> 'a list

List.rev [1,2,3];
val it = [3,2,1] : int list

Option;
val it =
  {app=fn,compose=fn,composePartial=fn,filter=fn,getOpt=fn,isSome=fn,join=fn,
   map=fn,mapPartial=fn,valOf=fn}
  : {app:('a option -> unit) -> 'a option -> unit, compose:('b -> 'c) * ('d -> 'b option) -> 'd -> 'c option, composePartial:('e -> 'f option) * ('g -> 'e option) -> 'g -> 'f option, filter:('h -> bool) -> 'h -> 'h option, getOpt:'i option * 'i -> 'i, isSome:'j option -> bool, join:'k option option -> 'k option, map:('l -> 'm) -> 'l option -> 'm option, mapPartial:('n -> 'o option) -> 'n option -> 'o option, valOf:'p option -> 'p}

Option.compose;
val it = fn : ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option

String;
val it =
  {concat=fn,concatWith=fn,explode=fn,extract=fn,implode=fn,isPrefix=fn,
   isSubstring=fn,isSuffix=fn,map=fn,maxSize=2147483647,size=fn,str=fn,sub=fn,
   substring=fn,translate=fn}
  : {concat:string list -> string, concatWith:string -> string list -> string, explode:string -> char list, extract:string * int * int option -> string, implode:char list -> string, isPrefix:string -> string -> bool, isSubstring:string -> string -> bool, isSuffix:string -> string -> bool, map:(char -> char) -> string -> string, maxSize:int, size:string -> int, str:char -> string, sub:string * int -> char, substring:string * int * int -> string, translate:(char -> string) -> string -> string}

Relational;
val it = {count=fn,max=fn,min=fn,sum=fn}
  : {count:'a list -> int, max:'b list -> 'b, min:'c list -> 'c, sum:'d list -> 'd}


(* Operators --------------------------------------------------- *)
2 + 3;
val it = 5 : int

2 + 3 * 4;
val it = 14 : int

Sys.plan ();
val it =
  "apply(fnValue +, argCode tuple(constant(2), apply(fnValue *, argCode tuple(constant(3), constant(4)))))"
  : string


fn x => x + 1;
val it = fn : int -> int

Sys.plan ();
val it = "match(x, apply(fnValue +, argCode tuple(get(name x), constant(1))))"
  : string


(* Datatypes --------------------------------------------------- *)

(*) datatype option
SOME 1;
val it = SOME 1 : int option

NONE;
val it = NONE : 'a option

SOME (SOME true);
val it = SOME SOME true : bool option option


(* General ----------------------------------------------------- *)

(*) op o - function composition
val plusOne = fn x => x + 1;
val plusOne = fn : int -> int

val timesTwo = fn x => x * 2;
val timesTwo = fn : int -> int

val plusThree = fn x => x + 3;
val plusThree = fn : int -> int

plusOne o timesTwo;
val it = fn : int -> int

(plusOne o timesTwo) 3;
val it = 7 : int

plusOne o timesTwo o plusThree;
val it = fn : int -> int

((plusOne o timesTwo) o plusThree) 3;
val it = 13 : int

(plusOne o (timesTwo o plusThree)) 3;
val it = 13 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue o, argCode tuple(get(name plusOne), apply(fnValue o, argCode tuple(get(name timesTwo), get(name plusThree))))), argCode constant(3))"
  : string


ignore;
val it = fn : 'a -> unit

ignore (1 + 2);
val it = () : unit

Sys.plan ();
val it =
  "apply(fnValue General.ignore, argCode apply(fnValue +, argCode tuple(constant(1), constant(2))))"
  : string


(* String ------------------------------------------------------ *)

(*) val maxSize : int
String.maxSize;
val it = 2147483647 : int

Sys.plan ();
val it = "apply(fnValue nth, argCode get(name String))" : string


(*) val size : string -> int
String.size;
val it = fn : string -> int

String.size "abc";
val it = 3 : int

String.size "";
val it = 0 : int

Sys.plan ();
val it = "apply(fnValue String.size, argCode constant())" : string


(*) val sub : string * int -> char
String.sub;
val it = fn : string * int -> char

String.sub("abc", 0);
val it = #"a" : char

String.sub("abc", 2);
val it = #"c" : char

String.sub("abc", 20);
uncaught exception Subscript [subscript out of bounds]

String.sub("abc", 3);
uncaught exception Subscript [subscript out of bounds]

String.sub("abc", ~1);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue String.sub, argCode tuple(constant(abc), constant(-1)))"
  : string


(*) val extract: string * int * int option -> string
String.extract;
val it = fn : string * int * int option -> string

String.extract("abc", 1, NONE);
val it = "bc" : string

String.extract("abc", 1, SOME 2);
val it = "bc" : string

String.extract("abc", 3, NONE);
val it = "" : string

String.extract("abc", 3, SOME 0);
val it = "" : string

String.extract("abc", 4, NONE);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", ~1, NONE);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", 4, SOME 2);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", ~1, SOME 2);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", 1, SOME ~1);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", 1, SOME 99);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue String.extract, argCode tuple(constant(abc), constant(1), apply(fnValue tyCon, argCode constant(99))))"
  : string


(*) val substring : string * int * int -> string
String.substring;
val it = fn : string * int * int -> string

String.substring("hello, world", 2, 7);
val it = "llo, wo" : string

String.substring("hello, world", 0, 1);
val it = "h" : string

String.substring("hello", 5, 0);
val it = "" : string

String.substring("hello", 1, 4);
val it = "ello" : string

String.substring("", 0, 0);
val it = "" : string

String.substring("hello", ~1, 0);
uncaught exception Subscript [subscript out of bounds]

String.substring("hello", 1, ~1);
uncaught exception Subscript [subscript out of bounds]

String.substring("hello", 1, 5);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue String.substring, argCode tuple(constant(hello), constant(1), constant(5)))"
  : string


(*) val ^ : string * string -> string
"a" ^ "bc";
val it = "abc" : string

"a" ^ "";
val it = "a" : string

"a" ^ "bc" ^ "" ^ "def";
val it = "abcdef" : string

Sys.plan ();
val it =
  "apply(fnValue ^, argCode tuple(apply(fnValue ^, argCode tuple(apply(fnValue ^, argCode tuple(constant(a), constant(bc))), constant())), constant(def)))"
  : string


(*) val concat : string list -> string
String.concat;
val it = fn : string list -> string

String.concat ["a", "bc", "def"];
val it = "abcdef" : string

String.concat ["a"];
val it = "a" : string

String.concat [];
val it = "" : string

Sys.plan ();
val it = "apply(fnValue String.concat, argCode tuple)" : string


(*) val concatWith : string -> string list -> string
String.concatWith;
val it = fn : string -> string list -> string

String.concatWith "," ["a", "bc", "def"];
val it = "a,bc,def" : string

String.concatWith "," ["a"];
val it = "a" : string

String.concatWith "," ["", ""];
val it = "," : string

String.concatWith "," [];
val it = "" : string

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.concatWith, argCode constant(,)), argCode tuple)"
  : string


(*) val str : char -> string
String.str;
val it = fn : char -> string

String.str #"a";
val it = "a" : string

Sys.plan ();
val it = "apply(fnValue String.str, argCode constant(a))" : string


(*) val implode : char list -> string
String.implode;
val it = fn : char list -> string

String.implode [#"a", #"b", #"c"];
val it = "abc" : string

String.implode [];
val it = "" : string

Sys.plan ();
val it = "apply(fnValue String.implode, argCode tuple)" : string


(*) val explode : string -> char list
String.explode;
val it = fn : string -> char list

String.explode "abc";
val it = [#"a",#"b",#"c"] : char list

String.explode "";
val it = [] : char list

Sys.plan ();
val it = "apply(fnValue String.explode, argCode constant())" : string


(*) val map : (char -> char) -> string -> string
String.map;
val it = fn : (char -> char) -> string -> string

String.map (fn c => if c = #"a" then #"A" else if c = #"c" then #"C" else c) "abc";
val it = "AbC" : string

String.map (fn c => if c = #"a" then #"A" else if c = #"c" then #"C" else c) "";
val it = "" : string

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.map, argCode match(c, if(condition apply(fnValue =, argCode tuple(get(name c), constant(a))), ifTrue constant(A), ifFalse if(condition apply(fnValue =, argCode tuple(get(name c), constant(c))), ifTrue constant(C), ifFalse get(name c))))), argCode constant())"
  : string


(*) val translate : (char -> string) -> string -> string
String.translate;
val it = fn : (char -> string) -> string -> string

String.translate (fn c => if c = #"a" then "AA" else if c = #"c" then "CCC" else "-") "abc";
val it = "AA-CCC" : string

String.translate (fn c => if c = #"a" then "AA" else if c = #"c" then "CCC" else "-") "";
val it = "" : string

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.translate, argCode match(c, if(condition apply(fnValue =, argCode tuple(get(name c), constant(a))), ifTrue constant(AA), ifFalse if(condition apply(fnValue =, argCode tuple(get(name c), constant(c))), ifTrue constant(CCC), ifFalse constant(-))))), argCode constant())"
  : string


(*) val tokens : (char -> bool) -> string -> string list
(*) val fields : (char -> bool) -> string -> string list
(*) val isPrefix    : string -> string -> bool
String.isPrefix;
val it = fn : string -> string -> bool

String.isPrefix "he" "hello";
val it = true : bool

String.isPrefix "el" "hello";
val it = false : bool

String.isPrefix "lo" "hello";
val it = false : bool

String.isPrefix "bonjour" "hello";
val it = false : bool

String.isPrefix "el" "";
val it = false : bool

String.isPrefix "" "hello";
val it = true : bool

String.isPrefix "" "";
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.isPrefix, argCode constant()), argCode constant())"
  : string


(*) val isSubstring : string -> string -> bool
String.isSubstring;
val it = fn : string -> string -> bool

String.isSubstring "he" "hello";
val it = true : bool

String.isSubstring "el" "hello";
val it = true : bool

String.isSubstring "lo" "hello";
val it = true : bool

String.isSubstring "bonjour" "hello";
val it = false : bool

String.isSubstring "el" "";
val it = false : bool

String.isSubstring "" "hello";
val it = true : bool

String.isSubstring "" "";
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.isSubstring, argCode constant()), argCode constant())"
  : string


(*) val isSuffix    : string -> string -> bool
String.isSuffix;
val it = fn : string -> string -> bool

String.isSuffix "he" "hello";
val it = false : bool

String.isSuffix "el" "hello";
val it = false : bool

String.isSuffix "lo" "hello";
val it = true : bool

String.isSuffix "bonjour" "hello";
val it = false : bool

String.isSuffix "el" "";
val it = false : bool

String.isSuffix "" "hello";
val it = true : bool

String.isSuffix "" "";
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.isSuffix, argCode constant()), argCode constant())"
  : string


(*) val compare : string * string -> order
(*) val collate : (char * char -> order) -> string * string -> order
(*) val <  : string * string -> bool
(*) val <= : string * string -> bool
(*) val >  : string * string -> bool
(*) val >= : string * string -> bool

(*) val toString : string -> String.string
(*) val scan       : (char, 'a) StringCvt.reader
(*)                    -> (string, 'a) StringCvt.reader
(*) val fromString : String.string -> string option
(*) val toCString : string -> String.string
(*) val fromCString : String.string -> string option

(* List -------------------------------------------------------- *)

(*) val nil : 'a list
List.nil;
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue nth, argCode get(name List))" : string


(*) val null : 'a list -> bool
List.null;
val it = fn : 'a list -> bool

List.null [];
val it = true : bool

List.null [1];
val it = false : bool

Sys.plan ();
val it = "apply(fnValue List.null, argCode tuple(constant(1)))" : string


(*) val length : 'a list -> int
List.length;
val it = fn : 'a list -> int

List.length [];
val it = 0 : int

List.length [1,2];
val it = 2 : int

Sys.plan ();
val it = "apply(fnValue List.length, argCode tuple(constant(1), constant(2)))"
  : string


(*) val @ : 'a list * 'a list -> 'a list
List.at;
val it = fn : 'a list * 'a list -> 'a list

List.at ([1], [2, 3]);
val it = [1,2,3] : int list

List.at ([1], []);
val it = [1] : int list

List.at ([], [2]);
val it = [2] : int list

List.at ([], []);
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.at, argCode tuple(tuple, tuple))" : string


[1] @ [2, 3];
val it = [1,2,3] : int list

[] @ [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.at, argCode tuple(tuple, tuple))" : string


(*) val hd : 'a list -> 'a
List.hd;
val it = fn : 'a list -> 'a

List.hd [1,2,3];
val it = 1 : int

List.hd [];
uncaught exception Empty

Sys.plan ();
val it = "apply(fnValue List.hd, argCode tuple)" : string


(*) val tl : 'a list -> 'a list
List.tl;
val it = fn : 'a list -> 'a list

List.tl [1,2,3];
val it = [2,3] : int list

List.tl [];
uncaught exception Empty

Sys.plan ();
val it = "apply(fnValue List.tl, argCode tuple)" : string


(*) val last : 'a list -> 'a
List.last;
val it = fn : 'a list -> 'a

List.last [1,2,3];
val it = 3 : int

List.last [];
uncaught exception Empty

Sys.plan ();
val it = "apply(fnValue List.last, argCode tuple)" : string


(*) val getItem : 'a list -> ('a * 'a list) option
List.getItem;
val it = fn : 'a list -> ('a * 'a list) option

List.getItem [1,2,3];
val it = SOME (1,[2,3]) : (int * int list) option

List.getItem [1];
val it = SOME (1,[]) : (int * int list) option

Sys.plan ();
val it = "apply(fnValue List.getItem, argCode tuple(constant(1)))" : string


(*) val nth : 'a list * int -> 'a
List.nth;
val it = fn : 'a list * int -> 'a

List.nth ([1,2,3], 2);
val it = 3 : int

List.nth ([1], 0);
val it = 1 : int

List.nth ([1,2,3], 3);
uncaught exception Subscript [subscript out of bounds]

List.nth ([1,2,3], ~1);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue List.nth, argCode tuple(tuple(constant(1), constant(2), constant(3)), constant(-1)))"
  : string


(*) val take : 'a list * int -> 'a list
List.take;
val it = fn : 'a list * int -> 'a list

List.take ([1,2,3], 0);
val it = [] : int list

List.take ([1,2,3], 1);
val it = [1] : int list

List.take ([1,2,3], 3);
val it = [1,2,3] : int list

List.take ([1,2,3], 4);
uncaught exception Subscript [subscript out of bounds]

List.take ([1,2,3], ~1);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue List.take, argCode tuple(tuple(constant(1), constant(2), constant(3)), constant(-1)))"
  : string


(*) val drop : 'a list * int -> 'a list
List.drop;
val it = fn : 'a list * int -> 'a list

List.drop ([1,2,3], 0);
val it = [1,2,3] : int list

List.drop ([1,2,3], 1);
val it = [2,3] : int list

List.drop ([1,2,3], 3);
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnValue List.drop, argCode tuple(tuple(constant(1), constant(2), constant(3)), constant(3)))"
  : string


(*) val rev : 'a list -> 'a list
List.rev;
val it = fn : 'a list -> 'a list

List.rev [1,2,3];
val it = [3,2,1] : int list

List.rev [2,1];
val it = [1,2] : int list

List.rev [1];
val it = [1] : int list

List.rev [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.rev, argCode tuple)" : string


(*) val concat : 'a list list -> 'a list
List.concat;
val it = fn : 'a list list -> 'a list

List.concat [[1],[2,3],[4,5,6]];
val it = [1,2,3,4,5,6] : int list

List.concat [[1],[],[4,5,6]];
val it = [1,4,5,6] : int list

List.concat [[],[],[]];
val it = [] : 'a list

List.concat [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.concat, argCode tuple)" : string


(*) val revAppend : 'a list * 'a list -> 'a list
List.revAppend;
val it = fn : 'a list * 'a list -> 'a list

List.revAppend ([1,2],[3,4,5]);
val it = [2,1,3,4,5] : int list

List.revAppend ([1],[3,4,5]);
val it = [1,3,4,5] : int list

List.revAppend ([],[3,4,5]);
val it = [3,4,5] : int list

List.revAppend ([1,2],[]);
val it = [2,1] : int list

List.revAppend ([],[]);
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.revAppend, argCode tuple(tuple, tuple))" : string


(*) val app : ('a -> unit) -> 'a list -> unit
List.app;
val it = fn : ('a -> unit) -> 'a list -> unit

List.app (fn x => ignore (x + 2)) [2,3,4];
val it = () : unit

List.app (fn x => ignore (x + 2)) [];
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.app, argCode match(x, apply(fnValue General.ignore, argCode apply(fnValue +, argCode tuple(get(name x), constant(2)))))), argCode tuple)"
  : string


(*) val map : ('a -> 'b) -> 'a list -> 'b list
List.map;
val it = fn : ('a -> 'b) -> 'a list -> 'b list

List.map (fn x => x + 1) [1,2,3];
val it = [2,3,4] : int list

List.map (fn x => x + 1) [];
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.map, argCode match(x, apply(fnValue +, argCode tuple(get(name x), constant(1))))), argCode tuple)"
  : string


(*) map is alias for List.map
map;
val it = fn : ('a -> 'b) -> 'a list -> 'b list

map (fn x => x) [];
val it = [] : 'a list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.map, argCode match(x, get(name x))), argCode tuple)"
  : string


(*) val mapPartial : ('a -> 'b option) -> 'a list -> 'b list
List.mapPartial;
val it = fn : ('a -> 'b option) -> 'a list -> 'b list

List.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) [1,2,3,5,8];
val it = [2,4,6] : int list

List.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) [];
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.mapPartial, argCode match(x, if(condition apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))), ifTrue constant([NONE]), ifFalse apply(fnValue tyCon, argCode apply(fnValue +, argCode tuple(get(name x), constant(1))))))), argCode tuple)"
  : string


(*) val find : ('a -> bool) -> 'a list -> 'a option
List.find;
val it = fn : ('a -> bool) -> 'a list -> 'a option

List.find (fn x => x mod 7 = 0) [2,3,5,8,13,21,34];
val it = SOME 21 : int option

List.find (fn x => x mod 11 = 0) [2,3,5,8,13,21,34];
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.find, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(11))), constant(0))))), argCode tuple(constant(2), constant(3), constant(5), constant(8), constant(13), constant(21), constant(34)))"
  : string


(*) val filter : ('a -> bool) -> 'a list -> 'a list
List.filter;
val it = fn : ('a -> bool) -> 'a list -> 'a list

List.filter (fn x => x mod 2 = 0) [0,1,2,3,4,5];
val it = [0,2,4] : int list

List.filter (fn x => x mod 2 = 0) [1,3];
val it = [] : int list

List.filter (fn x => x mod 2 = 0) [];
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.filter, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
List.partition;
val it = fn : ('a -> bool) -> 'a list -> 'a list * 'a list

List.partition (fn x => x mod 2 = 0) [0,1,2,3,4,5];
val it = ([0,2,4],[1,3,5]) : int list * int list

List.partition (fn x => x mod 2 = 0) [1];
val it = ([],[1]) : int list * int list

List.partition (fn x => x mod 2 = 0) [];
val it = ([],[]) : int list * int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.partition, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldl;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b

List.foldl (fn (a, b) => a + b) 0 [1,2,3];
val it = 6 : int

List.foldl (fn (a, b) => a + b) 0 [];
val it = 0 : int

List.foldl (fn (a, b) => b) 0 [1,2,3];
val it = 0 : int

List.foldl (fn (a, b) => a - b) 0 [1,2,3,4];
val it = 2 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue List.foldl, argCode match((a, b), apply(fnValue -, argCode tuple(get(name a), get(name b))))), argCode constant(0)), argCode tuple(constant(1), constant(2), constant(3), constant(4)))"
  : string


(*) val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldr;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b

List.foldr (fn (a, b) => a + b) 0 [1,2,3];
val it = 6 : int

List.foldr (fn (a, b) => a + b) 0 [];
val it = 0 : int

List.foldr (fn (a, b) => b) 0 [1,2,3];
val it = 0 : int

List.foldr (fn (a, b) => a - b) 0 [1,2,3,4];
val it = ~2 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue List.foldr, argCode match((a, b), apply(fnValue -, argCode tuple(get(name a), get(name b))))), argCode constant(0)), argCode tuple(constant(1), constant(2), constant(3), constant(4)))"
  : string


(*) val exists : ('a -> bool) -> 'a list -> bool
List.exists;
val it = fn : ('a -> bool) -> 'a list -> bool

List.exists (fn x => x mod 2 = 0) [1,3,5];
val it = false : bool

List.exists (fn x => x mod 2 = 0) [2,4,6];
val it = true : bool

List.exists (fn x => x mod 2 = 0) [1,2,3];
val it = true : bool

List.exists (fn x => x mod 2 = 0) [];
val it = false : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.exists, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val all : ('a -> bool) -> 'a list -> bool
List.all;
val it = fn : ('a -> bool) -> 'a list -> bool

List.all (fn x => x mod 2 = 0) [1,3,5];
val it = false : bool

List.all (fn x => x mod 2 = 0) [2,4,6];
val it = true : bool

List.all (fn x => x mod 2 = 0) [1,2,3];
val it = false : bool

List.all (fn x => x mod 2 = 0) [];
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.all, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val tabulate : int * (int -> 'a) -> 'a list
List.tabulate;
val it = fn : int * (int -> 'a) -> 'a list

List.tabulate (5, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = [1,1,2,6,24] : int list

List.tabulate (1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = [1] : int list

List.tabulate (0, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = [] : int list

List.tabulate (~1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
uncaught exception Size

Sys.plan ();
val it =
  "apply(fnValue List.tabulate, argCode tuple(constant(-1), let1(fnCode match(fact, match(n, if(condition apply(fnValue =, argCode tuple(get(name n), constant(0))), ifTrue constant(1), ifFalse apply(fnValue *, argCode tuple(get(name n), apply(fnCode link, argCode apply(fnValue -, argCode tuple(get(name n), constant(1))))))))), argCode get(name fact))))"
  : string


(*) val collate : ('a * 'a -> order) -> 'a list * 'a list -> order
List.collate;
val it = fn : ('a * 'a -> order) -> 'a list * 'a list -> order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1, 2,3], [1,3,4]);
val it = LESS : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2,2]);
val it = GREATER : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2]);
val it = GREATER : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2,3,4]);
val it = LESS : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], []);
val it = GREATER : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([], []);
val it = EQUAL : order

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.collate, argCode match((x, y), if(condition apply(fnValue <, argCode tuple(get(name x), get(name y))), ifTrue constant([LESS]), ifFalse if(condition apply(fnValue =, argCode tuple(get(name x), get(name y))), ifTrue constant([EQUAL]), ifFalse constant([GREATER]))))), argCode tuple(tuple, tuple))"
  : string


(* Option ------------------------------------------------------ *)
(*) val getOpt : 'a option * 'a -> 'a
Option.getOpt (SOME 1, 2);
val it = 1 : int

Option.getOpt (NONE, 2);
val it = 2 : int

Sys.plan ();
val it =
  "apply(fnValue Option.getOpt, argCode tuple(constant([NONE]), constant(2)))"
  : string


(*) val isSome : 'a option -> bool
Option.isSome (SOME 1);
val it = true : bool

Option.isSome NONE;
val it = false : bool

Sys.plan ();
val it = "apply(fnValue Option.isSome, argCode constant([NONE]))" : string


(*) val valOf : 'a option -> 'a
Option.valOf (SOME 1);
val it = 1 : int

(* sml-nj gives:
    stdIn:6.1-6.18 Warning: type vars not generalized because of
       value restriction are instantiated to dummy types (X1,X2,...)
 *)
Option.valOf NONE;
uncaught exception Option

val noneInt = if true then NONE else SOME 0;
val noneInt = NONE : int option

Option.valOf noneInt;
uncaught exception Option

Sys.plan ();
val it = "apply(fnValue Option.valOf, argCode get(name noneInt))" : string


(*) val filter : ('a -> bool) -> 'a -> 'a option
Option.filter (fn x => x mod 2 = 0) 1;
val it = NONE : int option

Option.filter (fn x => x mod 2 = 0) 2;
val it = SOME 2 : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.filter, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode constant(2))"
  : string


(*) val join : 'a option option -> 'a option
Option.join (SOME (SOME 1));
val it = SOME 1 : int option

Option.join (SOME noneInt);
val it = NONE : int option

(* sml-nj gives
  stdIn:1.2-1.18 Warning: type vars not generalized because of
     value restriction are instantiated to dummy types (X1,X2,...)
*)
Option.join NONE;
val it = NONE : 'a option

Sys.plan ();
val it = "apply(fnValue Option.join, argCode constant([NONE]))" : string


(*) val app : ('a -> unit) -> 'a option -> unit
Option.app General.ignore (SOME 1);
val it = () : unit

Option.app General.ignore NONE;
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.app, argCode apply(fnValue nth, argCode get(name General))), argCode constant([NONE]))"
  : string


(*) val map : ('a -> 'b) -> 'a option -> 'b option
Option.map String.size (SOME "xyz");
val it = SOME 3 : int option

Option.map String.size NONE;
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.map, argCode apply(fnValue nth, argCode get(name String))), argCode constant([NONE]))"
  : string


(*) val mapPartial : ('a -> 'b option) -> 'a option -> 'b option
Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) (SOME "xyz");
val it = SOME 3 : int option

Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) NONE;
val it = NONE : int option

Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) (SOME "");
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.mapPartial, argCode match(s, if(condition apply(fnValue =, argCode tuple(get(name s), constant())), ifTrue constant([NONE]), ifFalse apply(fnValue tyCon, argCode apply(fnValue String.size, argCode get(name s)))))), argCode apply(fnValue tyCon, argCode constant()))"
  : string


(*) val compose : ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option
Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 1, String.size s))))
               "";
val it = NONE : int option

Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 0, String.size s))))
               "a";
val it = SOME 1 : int option

Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 0, String.size s))))
               "";
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.compose, argCode tuple(apply(fnValue nth, argCode get(name String)), match(s, if(condition apply(fnValue =, argCode tuple(get(name s), constant())), ifTrue constant([NONE]), ifFalse apply(fnValue tyCon, argCode apply(fnValue String.substring, argCode tuple(get(name s), constant(0), apply(fnValue String.size, argCode get(name s))))))))), argCode constant())"
  : string


(*) val composePartial : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
Option.composePartial (fn i => if i = 0 then NONE else (SOME i),
                       fn s => if s = "" then NONE else SOME (String.size s))
                      "abc";
val it = SOME 3 : int option

Option.composePartial (fn i => if i = 0 then NONE else (SOME i),
                       fn s => if s = "" then NONE else SOME (String.size s))
                      "";
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.composePartial, argCode tuple(match(i, if(condition apply(fnValue =, argCode tuple(get(name i), constant(0))), ifTrue constant([NONE]), ifFalse apply(fnValue tyCon, argCode get(name i)))), match(s, if(condition apply(fnValue =, argCode tuple(get(name s), constant())), ifTrue constant([NONE]), ifFalse apply(fnValue tyCon, argCode apply(fnValue String.size, argCode get(name s))))))), argCode constant())"
  : string


(* Relational -------------------------------------------------- *)

Relational.count [1, 2, 3];
val it = 3 : int

Relational.count [];
val it = 0 : int

Relational.count [false];
val it = 1 : int

Sys.plan ();
val it = "apply(fnValue Relational.count, argCode tuple(get(name false)))"
  : string


Relational.sum [1, 2, 3];
val it = 6 : int

Relational.sum [1.0, 2.5, 3.5];
val it = 7.0 : real

Sys.plan ();
val it =
  "apply(fnValue Relational.sum$real, argCode tuple(constant(1.0), constant(2.5), constant(3.5)))"
  : string


Relational.max [1, 2, 3];
val it = 3 : int

Relational.max [1.0, 2.5, 3.5];
val it = 3.5 : real

Relational.max ["a", "bc", "ab"];
val it = "bc" : string

Relational.max [false, true];
val it = true : bool

Sys.plan ();
val it =
  "apply(fnValue Relational.max, argCode tuple(get(name false), get(name true)))"
  : string


Relational.min [1, 2, 3];
val it = 1 : int

Relational.min [1.0, 2.5, 3.5];
val it = 1.0 : real

Relational.min ["a", "bc", "ab"];
val it = "a" : string

Relational.min [false, true];
val it = false : bool

Sys.plan ();
val it =
  "apply(fnValue Relational.min, argCode tuple(get(name false), get(name true)))"
  : string


[1, 2] union [3] union [] union [4, 2, 5];
val it = [1,2,3,4,2,5] : int list

[] union [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.at, argCode tuple(tuple, tuple))" : string


[1, 2] except [2] except [3] except [];
val it = [1] : int list

[] except [];
val it = [] : 'a list

["a"] except ["a"];
val it = [] : string list

["a", "b", "c", "a"] except ["a"];
val it = ["b","c"] : string list

["a", "b", "c", "a"] except ["c", "b", "c"];
val it = ["a","a"] : string list

["a", "b"] except ["a", "c"] except ["a"];
val it = ["b"] : string list

Sys.plan ();
val it =
  "apply(fnValue except, argCode tuple(apply(fnValue except, argCode tuple(tuple(constant(a), constant(b)), tuple(constant(a), constant(c)))), tuple(constant(a))))"
  : string


[1, 2] intersect [2] intersect [0, 2, 4];
val it = [2] : int list

[1, 2] intersect [];
val it = [] : int list

[] intersect [1, 2];
val it = [] : int list

["a", "b", "a"] intersect ["b", "a"];
val it = ["a","b","a"] : string list

[(1, 2), (2, 3)] intersect [(2, 4), (1, 2)];
val it = [(1,2)] : (int * int) list

[1, 2, 3] intersect [2, 3, 4] except [1, 3, 5];
val it = [2] : int list

[1, 2, 3] except [1, 3, 5] intersect [2, 3, 4];
val it = [1,2] : int list

Sys.plan ();
val it =
  "apply(fnValue except, argCode tuple(tuple(constant(1), constant(2), constant(3)), apply(fnValue intersect, argCode tuple(tuple(constant(1), constant(3), constant(5)), tuple(constant(2), constant(3), constant(4))))))"
  : string


1 elem [1, 2, 3];
val it = true : bool

1 elem [2, 3, 4];
val it = false : bool

1 elem [];
val it = false : bool

[] elem [[0], [1, 2]];
val it = false : bool

[] elem [[0], [], [1, 2]];
val it = true : bool

(1, 2) elem [(0, 1), (1, 2)];
val it = true : bool

(1, 2) elem [(0, 1), (2, 3)];
val it = false : bool

Sys.plan ();
val it =
  "apply(fnValue elem, argCode tuple(tuple(constant(1), constant(2)), tuple(tuple(constant(0), constant(1)), tuple(constant(2), constant(3)))))"
  : string


1 notElem [1, 2, 3];
val it = false : bool

1 notElem [2, 3, 4];
val it = true : bool

1 notElem [];
val it = true : bool

[] notElem [[0], [1, 2]];
val it = true : bool

[] notElem [[0], [], [1, 2]];
val it = false : bool

(1, 2) notElem [(0, 1), (1, 2)];
val it = false : bool

(1, 2) notElem [(0, 1), (2, 3)];
val it = true : bool

Sys.plan ();
val it =
  "apply(fnValue nonElem, argCode tuple(tuple(constant(1), constant(2)), tuple(tuple(constant(0), constant(1)), tuple(constant(2), constant(3)))))"
  : string


(* Sys --------------------------------------------------------- *)

(*) val env : unit -> string list
Sys.env;
val it = fn : unit -> (string * string) list

Sys.env ();
val it =
  [("EQUAL","order"),("GREATER","order"),
   ("General",
   "{ignore:forall 'a. 'a -> unit, op o:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c}"),
   ("LESS","order"),
   ("List",
   "{all:forall 'a. ('a -> bool) -> 'a list -> bool, app:forall 'a. ('a -> unit) -> 'a list -> unit, at:forall 'a. 'a list * 'a list -> 'a list, collate:forall 'a. ('a * 'a -> order) -> 'a list * 'a list -> order, concat:forall 'a. 'a list list -> 'a list, drop:forall 'a. 'a list * int -> 'a list, exists:forall 'a. ('a -> bool) -> 'a list -> bool, filter:forall 'a. ('a -> bool) -> 'a list -> 'a list, find:forall 'a. ('a -> bool) -> 'a list -> 'a option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, getItem:forall 'a. 'a list -> ('a * 'a list) option, hd:forall 'a. 'a list -> 'a, last:forall 'a. 'a list -> 'a, length:forall 'a. 'a list -> int, map:forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a list -> 'b list, nil:forall 'a. 'a list, nth:forall 'a. 'a list * int -> 'a, null:forall 'a. 'a list -> bool, op @:forall 'a. 'a list * 'a list -> 'a list, partition:forall 'a. ('a -> bool) -> 'a list -> 'a list * 'a list, rev:forall 'a. 'a list -> 'a list, revAppend:forall 'a. 'a list * 'a list -> 'a list, tabulate:forall 'a. int * (int -> 'a) -> 'a list, take:forall 'a. 'a list * int -> 'a list, tl:forall 'a. 'a list -> 'a list}"),
   ("NONE","'a option"),
   ("Option",
   "{app:forall 'a. ('a option -> unit) -> 'a option -> unit, compose:forall 'a 'b 'c. ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option, composePartial:forall 'a 'b 'c. ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option, filter:forall 'a. ('a -> bool) -> 'a -> 'a option, getOpt:forall 'a. 'a option * 'a -> 'a, isSome:forall 'a. 'a option -> bool, join:forall 'a. 'a option option -> 'a option, map:forall 'a 'b. ('a -> 'b) -> 'a option -> 'b option, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a option -> 'b option, valOf:forall 'a. 'a option -> 'a}"),
   ("Relational",
   "{count:forall 'a. 'a list -> int, max:forall 'a. 'a list -> 'a, min:forall 'a. 'a list -> 'a, sum:forall 'a. 'a list -> 'a}"),
   ("SOME","forall 'a. 'a -> 'a option"),
   ("String",
   "{concat:string list -> string, concatWith:string -> string list -> string, explode:string -> char list, extract:string * int * int option -> string, implode:char list -> string, isPrefix:string -> string -> bool, isSubstring:string -> string -> bool, isSuffix:string -> string -> bool, map:(char -> char) -> string -> string, maxSize:int, size:string -> int, str:char -> string, sub:string * int -> char, substring:string * int * int -> string, translate:(char -> string) -> string -> string}"),
   ("Sys","{env:unit -> (string * string) list, plan:unit -> string}"),
   ("Vector",
   "{all:forall 'a. ('a -> bool) -> 'a vector -> bool, app:forall 'a. ('a -> unit) -> 'a vector -> unit, appi:forall 'a. (int * 'a -> unit) -> 'a vector -> unit, collate:forall 'a. ('a * 'a -> order) -> 'a vector * 'a vector -> order, concat:forall 'a. 'a vector list -> 'a vector, exists:forall 'a. ('a -> bool) -> 'a vector -> bool, find:forall 'a. ('a -> bool) -> 'a vector -> 'a option, findi:forall 'a 'b. (int * 'a -> bool) -> 'a vector -> (int * 'a) option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldli:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldri:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, fromList:forall 'a. 'a list -> 'a vector, length:forall 'a. 'a vector -> int, map:forall 'a 'b. ('a -> 'b) -> 'a vector -> 'b vector, mapi:forall 'a 'b. (int * 'a -> 'b) -> 'a vector -> 'b vector, maxLen:int, sub:forall 'a. 'a vector * int -> 'a, tabulate:forall 'a. int * (int -> 'a) -> 'a vector, update:forall 'a. 'a vector * int * 'a -> 'a vector}"),
   ...] : (string * string) list


env;
val it = fn : unit -> (string * string) list

env ();
val it =
  [("EQUAL","order"),("GREATER","order"),
   ("General",
   "{ignore:forall 'a. 'a -> unit, op o:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c}"),
   ("LESS","order"),
   ("List",
   "{all:forall 'a. ('a -> bool) -> 'a list -> bool, app:forall 'a. ('a -> unit) -> 'a list -> unit, at:forall 'a. 'a list * 'a list -> 'a list, collate:forall 'a. ('a * 'a -> order) -> 'a list * 'a list -> order, concat:forall 'a. 'a list list -> 'a list, drop:forall 'a. 'a list * int -> 'a list, exists:forall 'a. ('a -> bool) -> 'a list -> bool, filter:forall 'a. ('a -> bool) -> 'a list -> 'a list, find:forall 'a. ('a -> bool) -> 'a list -> 'a option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, getItem:forall 'a. 'a list -> ('a * 'a list) option, hd:forall 'a. 'a list -> 'a, last:forall 'a. 'a list -> 'a, length:forall 'a. 'a list -> int, map:forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a list -> 'b list, nil:forall 'a. 'a list, nth:forall 'a. 'a list * int -> 'a, null:forall 'a. 'a list -> bool, op @:forall 'a. 'a list * 'a list -> 'a list, partition:forall 'a. ('a -> bool) -> 'a list -> 'a list * 'a list, rev:forall 'a. 'a list -> 'a list, revAppend:forall 'a. 'a list * 'a list -> 'a list, tabulate:forall 'a. int * (int -> 'a) -> 'a list, take:forall 'a. 'a list * int -> 'a list, tl:forall 'a. 'a list -> 'a list}"),
   ("NONE","'a option"),
   ("Option",
   "{app:forall 'a. ('a option -> unit) -> 'a option -> unit, compose:forall 'a 'b 'c. ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option, composePartial:forall 'a 'b 'c. ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option, filter:forall 'a. ('a -> bool) -> 'a -> 'a option, getOpt:forall 'a. 'a option * 'a -> 'a, isSome:forall 'a. 'a option -> bool, join:forall 'a. 'a option option -> 'a option, map:forall 'a 'b. ('a -> 'b) -> 'a option -> 'b option, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a option -> 'b option, valOf:forall 'a. 'a option -> 'a}"),
   ("Relational",
   "{count:forall 'a. 'a list -> int, max:forall 'a. 'a list -> 'a, min:forall 'a. 'a list -> 'a, sum:forall 'a. 'a list -> 'a}"),
   ("SOME","forall 'a. 'a -> 'a option"),
   ("String",
   "{concat:string list -> string, concatWith:string -> string list -> string, explode:string -> char list, extract:string * int * int option -> string, implode:char list -> string, isPrefix:string -> string -> bool, isSubstring:string -> string -> bool, isSuffix:string -> string -> bool, map:(char -> char) -> string -> string, maxSize:int, size:string -> int, str:char -> string, sub:string * int -> char, substring:string * int * int -> string, translate:(char -> string) -> string -> string}"),
   ("Sys","{env:unit -> (string * string) list, plan:unit -> string}"),
   ("Vector",
   "{all:forall 'a. ('a -> bool) -> 'a vector -> bool, app:forall 'a. ('a -> unit) -> 'a vector -> unit, appi:forall 'a. (int * 'a -> unit) -> 'a vector -> unit, collate:forall 'a. ('a * 'a -> order) -> 'a vector * 'a vector -> order, concat:forall 'a. 'a vector list -> 'a vector, exists:forall 'a. ('a -> bool) -> 'a vector -> bool, find:forall 'a. ('a -> bool) -> 'a vector -> 'a option, findi:forall 'a 'b. (int * 'a -> bool) -> 'a vector -> (int * 'a) option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldli:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldri:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, fromList:forall 'a. 'a list -> 'a vector, length:forall 'a. 'a vector -> int, map:forall 'a 'b. ('a -> 'b) -> 'a vector -> 'b vector, mapi:forall 'a 'b. (int * 'a -> 'b) -> 'a vector -> 'b vector, maxLen:int, sub:forall 'a. 'a vector * int -> 'a, tabulate:forall 'a. int * (int -> 'a) -> 'a vector, update:forall 'a. 'a vector * int * 'a -> 'a vector}"),
   ...] : (string * string) list


(*) val plan : string
Sys.plan;
val it = fn : unit -> string

1 + 2;
val it = 3 : int

Sys.plan ();
val it = "apply(fnValue +, argCode tuple(constant(1), constant(2)))" : string


(* Vector ------------------------------------------------------ *)

(*) Vector.fromList : 'a list -> 'a vector
Vector.fromList;
val it = fn : 'a list -> 'a vector

Vector.fromList [1,2];
val it = #[1,2] : int vector

Sys.plan ();
val it =
  "apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(2)))"
  : string


(* supported in sml-nj but not morel:
 #[1,2];
 *)

(* sml-nj says:
  stdIn:3.1-3.19 Warning: type vars not generalized because of
     value restriction are instantiated to dummy types (X1,X2,...)
  val it = #[] : ?.X1 vector
*)
Vector.fromList [];
val it = #[] : 'a vector

Sys.plan ();
val it = "apply(fnValue Vector.fromList, argCode tuple)" : string


(*) Vector.maxLen: int
Vector.maxLen;
val it = 16777215 : int

Sys.plan ();
val it = "apply(fnValue nth, argCode get(name Vector))" : string


(*) Vector.tabulate : int * (int -> 'a) -> 'a vector
Vector.tabulate;
val it = fn : int * (int -> 'a) -> 'a vector

Vector.tabulate (5, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = #[1,1,2,6,24] : int vector

Sys.plan ();
val it =
  "apply(fnValue List.tabulate, argCode tuple(constant(5), let1(fnCode match(fact, match(n, if(condition apply(fnValue =, argCode tuple(get(name n), constant(0))), ifTrue constant(1), ifFalse apply(fnValue *, argCode tuple(get(name n), apply(fnCode link, argCode apply(fnValue -, argCode tuple(get(name n), constant(1))))))))), argCode get(name fact))))"
  : string


(*) Vector.length : 'a vector -> int
Vector.length;
val it = fn : 'a vector -> int

Vector.length (Vector.fromList [1,2,3]);
val it = 3 : int

Sys.plan ();
val it =
  "apply(fnValue List.length, argCode apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(2), constant(3))))"
  : string


(*) Vector.sub : 'a vector * int -> 'a
Vector.sub;
val it = fn : 'a vector * int -> 'a

Vector.sub (Vector.fromList [3,6,9], 2);
val it = 9 : int

Vector.sub (Vector.fromList [3,6,9], ~1);
uncaught exception Subscript [subscript out of bounds]

Vector.sub (Vector.fromList [3,6,9], 3);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue List.nth, argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(6), constant(9))), constant(3)))"
  : string


(*) Vector.update : 'a vector * int * 'a -> 'a vector
Vector.update;
val it = fn : 'a vector * int * 'a -> 'a vector

Vector.update (Vector.fromList ["a","b","c"], 1, "baz");
val it = #["a","baz","c"] : string vector

Vector.update (Vector.fromList ["a","b","c"], ~1, "baz");
uncaught exception Subscript [subscript out of bounds]

Vector.update (Vector.fromList ["a","b","c"], 3, "baz");
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue Vector.update, argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))), constant(3), constant(baz)))"
  : string


(*) Vector.concat : 'a vector list -> 'a vector
Vector.concat;
val it = fn : 'a vector list -> 'a vector

Vector.concat [Vector.fromList ["a","b"],
  Vector.fromList [], Vector.fromList ["c"]];
val it = #["a","b","c"] : string vector

Sys.plan ();
val it =
  "apply(fnValue Vector.concat, argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b))), apply(fnValue Vector.fromList, argCode tuple), apply(fnValue Vector.fromList, argCode tuple(constant(c)))))"
  : string


(*) Vector.appi : (int * 'a -> unit) -> 'a vector -> unit
Vector.appi;
val it = fn : (int * 'a -> unit) -> 'a vector -> unit

Vector.appi (fn (i,s) => ignore s) (Vector.fromList ["a", "b", "c"]);
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.appi, argCode match((i, s), apply(fnValue General.ignore, argCode get(name s)))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))))"
  : string


(*) Vector.app  : ('a -> unit) -> 'a vector -> unit
Vector.app;
val it = fn : ('a -> unit) -> 'a vector -> unit

Vector.app (fn s => ignore s) (Vector.fromList ["a", "b", "c"]);
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.app, argCode match(s, apply(fnValue General.ignore, argCode get(name s)))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))))"
  : string


(*) Vector.mapi : (int * 'a -> 'b) -> 'a vector -> 'b vector
Vector.mapi;
val it = fn : (int * 'a -> 'b) -> 'a vector -> 'b vector

Vector.mapi (fn (i, s) => String.sub (s, i)) (Vector.fromList ["abc", "xyz"]);
val it = #[#"a",#"y"] : char vector

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.mapi, argCode match((i, s), apply(fnValue String.sub, argCode tuple(get(name s), get(name i))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(abc), constant(xyz))))"
  : string


(*) Vector.map  : ('a -> 'b) -> 'a vector -> 'b vector
Vector.map;
val it = fn : ('a -> 'b) -> 'a vector -> 'b vector

Vector.map (fn s => String.sub (s, 0)) (Vector.fromList ["abc", "xyz"]);
val it = #[#"a",#"x"] : char vector

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.map, argCode match(s, apply(fnValue String.sub, argCode tuple(get(name s), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(abc), constant(xyz))))"
  : string


(*) Vector.foldli : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldli;
val it = fn : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldli (fn (i,j,a) => a + i * j) 0 (Vector.fromList [2,3,4]);
val it = 11 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldli, argCode match((i, j, a), apply(fnValue +, argCode tuple(get(name a), apply(fnValue *, argCode tuple(get(name i), get(name j))))))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.foldri : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldri;
val it = fn : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldri (fn (i,j,a) => a + i * j) 0 (Vector.fromList [2,3,4]);
val it = 11 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldri, argCode match((i, j, a), apply(fnValue +, argCode tuple(get(name a), apply(fnValue *, argCode tuple(get(name i), get(name j))))))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.foldl  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldl;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldl (fn (j,a) => a + j) 0 (Vector.fromList [2,3,4]);
val it = 9 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldl, argCode match((j, a), apply(fnValue +, argCode tuple(get(name a), get(name j))))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.foldr  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldr;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldr (fn (j,a) => a + j) 0 (Vector.fromList [2,3,4]);
val it = 9 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldr, argCode match((j, a), apply(fnValue +, argCode tuple(get(name a), get(name j))))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.findi : (int * 'a -> bool) -> 'a vector -> (int * 'a) option
Vector.findi;
val it = fn : (int * 'a -> bool) -> 'a vector -> (int * 'a) option

Vector.findi (fn (i,j) => j < i) (Vector.fromList [10,8,6,4,2]);
val it = SOME (4,2) : (int * int) option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.findi, argCode match((i, j), apply(fnValue <, argCode tuple(get(name j), get(name i))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(10), constant(8), constant(6), constant(4), constant(2))))"
  : string


(*) Vector.find  : ('a -> bool) -> 'a vector -> 'a option
Vector.find;
val it = fn : ('a -> bool) -> 'a vector -> 'a option

Vector.find (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
val it = SOME 8 : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.find, argCode match(j, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name j), constant(2))), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
  : string


(*) Vector.exists : ('a -> bool) -> 'a vector -> bool
Vector.exists;
val it = fn : ('a -> bool) -> 'a vector -> bool

Vector.exists (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.exists, argCode match(j, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name j), constant(2))), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
  : string


(*) Vector.all : ('a -> bool) -> 'a vector -> bool
Vector.all;
val it = fn : ('a -> bool) -> 'a vector -> bool

Vector.all (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
val it = false : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.all, argCode match(j, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name j), constant(2))), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
  : string


(*) Vector.collate : ('a * 'a -> order) -> 'a vector * 'a vector -> order
Vector.collate;
val it = fn : ('a * 'a -> order) -> 'a vector * 'a vector -> order

Vector.collate
  (fn (i,j) => if i < j then LESS else if i = j then EQUAL else GREATER)
  (Vector.fromList [1,3,5], Vector.fromList [1,3,6]);
val it = LESS : order

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.collate, argCode match((i, j), if(condition apply(fnValue <, argCode tuple(get(name i), get(name j))), ifTrue constant([LESS]), ifFalse if(condition apply(fnValue =, argCode tuple(get(name i), get(name j))), ifTrue constant([EQUAL]), ifFalse constant([GREATER]))))), argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(3), constant(5))), apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(3), constant(6)))))"
  : string
